// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

use std::ops::{Deref, DerefMut};

use bitstruct::bitstruct;
use strum::FromRepr;
use zerocopy::{FromBytes, Immutable};

use crate::{
    common::GuestAddr,
    hw::usb::xhci::{device_slots::SlotId, port::PortId},
};

/// See xHCI 1.2 sect 4.5.3 & table 6-7
#[derive(Copy, Clone, FromRepr, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum SlotState {
    DisabledEnabled = 0,
    Default = 1,
    Addressed = 2,
    Configured = 3,
    Reserved4 = 4,
    Reserved5 = 5,
    Reserved6 = 6,
    Reserved7 = 7,
    Reserved8 = 8,
    Reserved9 = 9,
    Reserved10 = 10,
    Reserved11 = 11,
    Reserved12 = 12,
    Reserved13 = 13,
    Reserved14 = 14,
    Reserved15 = 15,
    Reserved16 = 16,
    Reserved17 = 17,
    Reserved18 = 18,
    Reserved19 = 19,
    Reserved20 = 20,
    Reserved21 = 21,
    Reserved22 = 22,
    Reserved23 = 23,
    Reserved24 = 24,
    Reserved25 = 25,
    Reserved26 = 26,
    Reserved27 = 27,
    Reserved28 = 28,
    Reserved29 = 29,
    Reserved30 = 30,
    Reserved31 = 31,
}

impl Into<u8> for SlotState {
    fn into(self) -> u8 {
        self as u8
    }
}
impl From<u8> for SlotState {
    fn from(value: u8) -> Self {
        Self::from_repr(value).expect("SlotState should only be converted from a 5-bit field in SlotContext")
    }
}

#[derive(Copy, Clone, Immutable, FromBytes, Debug)]
#[repr(C)]
pub struct SlotContext {
    first: SlotContextFirst,
    reserved: u128,
}

// HACK: the .with_* from bitstruct will only return First,
// but we ultimately only care about .set_*
impl Deref for SlotContext {
    type Target = SlotContextFirst;
    fn deref(&self) -> &Self::Target {
        &self.first
    }
}
impl DerefMut for SlotContext {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.first
    }
}

bitstruct! {
    /// Representation of the first half of a Slot Context.
    /// (the second half is 128-bits of reserved.)
    ///
    /// See xHCI 1.2 Section 6.2.2
    #[derive(Clone, Copy, Default, Immutable, FromBytes)]
    pub struct SlotContextFirst(pub u128) {
        /// Used by hubs to route packets to the correct port. (USB3 section 8.9)
        pub route_string: u32 = 0..20;

        /// Deprecated in xHCI.
        speed: u8 = 20..24;

        reserved0: bool = 24;

        /// Set to 1 by software to enable a hub's Multi-TT (Transaction Translator)
        /// interface, if supported by the hub.
        pub multi_tt: bool = 25;

        pub hub: bool = 26;

        /// Index of the last valid endpoint context within the Device Context
        /// that contains this Slot Context. Valid values are 1 through 31.
        pub context_entries: u8 = 27..32;

        /// Indicates the worst-case time it takes to wake up all the links
        /// in the path to the device, given the current USB link level power
        /// management settings, in microseconds.
        pub max_exit_latency_micros: u16 = 32..48;

        /// Indicates the root hub port number used to access this device.
        /// Valid values are 1 through the controller's max number of ports.
        /// (See xHCI 1.2 sect 4.19.7 for numbering info)
        pub root_hub_port_number_: u8 = 48..56;

        /// If this device is a hub, guest sets this to the number of
        /// downstream-facing ports supported by the hub. (USB2 table 11-13)
        pub number_of_ports: u8 = 56..64;

        pub parent_hub_slot_id: SlotId = 64..72;

        pub parent_port_number: u8 = 72..80;

        pub tt_think_time: u8 = 80..82;

        reserved1: u8 = 82..86;

        /// The index of the interrupter to receive Bandwidth Request Events
        /// and Device Notification Events generated by this slot, or when a
        /// Ring Underrun or Ring Overrun condition is reported. Valid values
        /// are 0..NUM_INTRS
        pub interrupter_target: u16 = 86..96;

        /// The address assigned to the USB device in this slot by the xHC,
        /// set during a successful Set Address command.
        pub usb_device_address: u8 = 96..104;

        reserved2: u32 = 104..123;

        /// Updated by xHC when device slot transitions states.
        pub slot_state: SlotState = 123..128
    }
}

impl SlotContextFirst {
    pub fn root_hub_port_number(&self) -> Result<PortId, String> {
        PortId::try_from(self.root_hub_port_number_())
    }
    pub fn with_root_hub_port_number(self, port_id: PortId) -> Self {
        self.with_root_hub_port_number_(port_id.as_raw_id())
    }
    pub fn set_root_hub_port_number(&mut self, port_id: PortId) {
        self.set_root_hub_port_number_(port_id.as_raw_id());
    }
}

impl core::fmt::Debug for SlotContextFirst {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SlotContextFirst {{ \
            route_string: {}, \
            multi_tt: {}, \
            hub: {}, \
            context_entries: {}, \
            max_exit_latency_micros: {}, \
            root_hub_port_number: {:?}, \
            number_of_ports: {}, \
            parent_hub_slot_id: {:?}, \
            parent_port_number: {}, \
            tt_think_time: {}, \
            interrupter_target: {}, \
            usb_device_address: {}, \
            slot_state: {:?} }}",
            self.route_string(),
            self.multi_tt(),
            self.hub(),
            self.context_entries(),
            self.max_exit_latency_micros(),
            self.root_hub_port_number(),
            self.number_of_ports(),
            self.parent_hub_slot_id(),
            self.parent_port_number(),
            self.tt_think_time(),
            self.interrupter_target(),
            self.usb_device_address(),
            self.slot_state()
        )
    }
}

/// See xHCI 1.2 table 6-8
#[derive(Copy, Clone, FromRepr, Debug, Eq, PartialEq)]
#[repr(u8)]
pub enum EndpointState {
    Disabled = 0,
    Running = 1,
    Halted = 2,
    Stopped = 3,
    Error = 4,
    Reserved5 = 5,
    Reserved6 = 6,
    Reserved7 = 7,
}

impl Into<u8> for EndpointState {
    fn into(self) -> u8 {
        self as u8
    }
}
impl From<u8> for EndpointState {
    fn from(value: u8) -> Self {
        Self::from_repr(value).expect("EndpointState should only be converted from a 3-bit field in EndpointContext")
    }
}

/// See xHCI 1.2 table 6-8
#[derive(Copy, Clone, FromRepr, Debug)]
#[repr(u8)]
pub enum EndpointType {
    NotValid = 0,
    IsochOut = 1,
    BulkOut = 2,
    InterruptOut = 3,
    Control = 4,
    IsochIn = 5,
    BulkIn = 6,
    InterruptIn = 7,
}

impl Into<u8> for EndpointType {
    fn into(self) -> u8 {
        self as u8
    }
}
impl From<u8> for EndpointType {
    fn from(value: u8) -> Self {
        Self::from_repr(value).expect("EndpointType should only be converted from a 3-bit field in EndpointContext")
    }
}

#[derive(Copy, Clone, Immutable, FromBytes, Debug)]
#[repr(C)]
pub struct EndpointContext {
    first: EndpointContextFirst,
    second: EndpointContextSecond,
}

impl Deref for EndpointContext {
    type Target = EndpointContextFirst;
    fn deref(&self) -> &Self::Target {
        &self.first
    }
}
impl DerefMut for EndpointContext {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.first
    }
}

impl EndpointContext {
    pub fn average_trb_length(&self) -> u16 {
        self.second.average_trb_length()
    }
    pub fn set_average_trb_length(&mut self, value: u16) {
        self.second.set_average_trb_length(value)
    }

    /// xHCI 1.2 section 6.2.3.2
    pub fn valid_for_configure_endpoint(&self) -> bool {
        // TODO: 1) the values of Max Packet Size, Max Burst Size, and Interval
        //  are within range for the endpoint type and speed of the device,
        // TODO: 2) if MaxPStreams > 0, the TR Dequeue Pointer field points
        //  to a an array of valid Stream Contexts, or if MaxPStreams == 0,
        //  the TR Dequeue Pointer field points to a Transfer Ring,
        // 3) the EP State field = Disabled,
        self.endpoint_state() == EndpointState::Disabled
        // 4) all other fields are within their valid range of values:
        && self.mult() == 0 // SS Isoch not implemented
        && self.max_primary_streams() == 0 // SS not implemented
        && !self.linear_stream_array() // RsvdZ if MaxPStreams == 0

        /* TODO: interval is valid per table 6-12 */
        /* TODO: other fields */
    }
}

bitstruct! {
    /// Representation of the first half of an Endpoint Context.
    ///
    /// See xHCI 1.2 Section 6.2.3
    #[derive(Clone, Copy, Default, Immutable, FromBytes)]
    pub struct EndpointContextFirst(pub u128) {
        /// EP State. Current operational state of the Endpoint.
        pub endpoint_state: EndpointState = 0..3;

        reserved1: u8 = 3..8;

        /// If LEC=0, indicates one less than the maximum number of bursts
        /// within an Interval that this endpoint supports.
        /// Valid values are 0..=2 for SS Isoch, 0 for all other endpoints.
        pub mult: u8 = 8..10;

        /// Maximum Primary Streams (MaxPStreams).
        /// Maximum number of Primary Stream IDs this endpoint supports.
        /// 0 indicates Streams are not supported by this endpoint,
        /// and tr_dequeue_pointer points to a Transfer Ring.
        /// Nonzero values indicate that the tr_dequeue_pointer points to a
        /// Primrary Stream Context Array (see xHCI 1.2 sect 4.12).
        /// Values of 1 to 15 indicate that the Primary Stream ID Width is
        /// (MaxPStreams+1) and the Primary Stream Array contains
        /// (2 << MaxPStreams) entries.
        /// For SS Bulk endpoints, valid values are defined by MaxPSASize
        /// in HCCPARAMS1. Must be 0 for all non-SS endpoints, and for
        /// SS Control, SS Isoch and SS Interrupt endpoints.
        pub max_primary_streams: u8 = 10..15;

        /// Linear Stream Array (LSA).
        /// If MaxPStreams = 0, this field is RsvdZ.
        pub linear_stream_array: bool = 15;

        /// Interval. The period between consecutive requests to USB endpoint
        /// to send or receive data. The period is calculated as
        /// (125 * (1 << interval)) microseconds. See xHCI 1.2 table 6-12.
        pub interval: u8 = 16..24;

        pub max_endpoint_service_time_interval_payload_high: u8 = 24..32;

        reserved2: bool = 32;

        pub error_count: u8 = 33..35;

        pub endpoint_type: EndpointType = 35..38;

        reserved3: bool = 38;

        pub host_initiate_disable: bool = 39;

        pub max_burst_size: u8 = 40..48;

        pub max_packet_size: u16 = 48..64;

        pub dequeue_cycle_state: bool = 64;

        reserved4: u8 = 65..68;

        tr_dequeue_pointer_: u64 = 68..128;
    }
}

impl core::fmt::Debug for EndpointContextFirst {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EndpointContextFirst {{ \
            endpoint_state: {:?}, \
            mult: {}, \
            max_primary_streams: {}, \
            linear_stream_array: {}, \
            interval: {}, \
            max_endpoint_service_time_interval_payload_high: {}, \
            error_count: {}, \
            endpoint_type: {:?}, \
            host_initiate_disable: {}, \
            max_burst_size: {}, \
            max_packet_size: {}, \
            dequeue_cycle_state: {}, \
            tr_dequeue_pointer: {:?} }}",
            self.endpoint_state(),
            self.mult(),
            self.max_primary_streams(),
            self.linear_stream_array(),
            self.interval(),
            self.max_endpoint_service_time_interval_payload_high(),
            self.error_count(),
            self.endpoint_type(),
            self.host_initiate_disable(),
            self.max_burst_size(),
            self.max_packet_size(),
            self.dequeue_cycle_state(),
            self.tr_dequeue_pointer(),
        )
    }
}

impl EndpointContextFirst {
    pub fn tr_dequeue_pointer(&self) -> GuestAddr {
        GuestAddr(self.tr_dequeue_pointer_() << 4)
    }
    #[must_use]
    pub const fn with_tr_dequeue_pointer(self, value: GuestAddr) -> Self {
        self.with_tr_dequeue_pointer_(value.0 >> 4)
    }
    pub fn set_tr_dequeue_pointer(&mut self, value: GuestAddr) {
        self.set_tr_dequeue_pointer_(value.0 >> 4);
    }
}

bitstruct! {
    /// Representation of the second half of an Endpoint Context.
    ///
    /// See xHCI 1.2 Section 6.2.3
    #[derive(Clone, Copy, Default, Immutable, FromBytes)]
    pub struct EndpointContextSecond(pub u128) {
        pub average_trb_length: u16 = 0..16;

        pub max_endpoint_service_time_interval: u16 = 16..32;

        reserved0: u128 = 32..128;
    }
}

impl core::fmt::Debug for EndpointContextSecond {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EndpointContextSecond {{ \
            average_trb_length: {}, \
            max_endpoint_service_time_interval: {} }}",
            self.average_trb_length(),
            self.max_endpoint_service_time_interval(),
        )
    }
}

#[repr(C)]
#[derive(Copy, Clone, Immutable, FromBytes, Debug)]
pub struct InputControlContext {
    drop_context: AddDropContextFlags,
    add_context: AddDropContextFlags,
    reserved: [u32; 5],
    last: InputControlContextLast,
}
// would love to use bitvec::BitArr!, but need FromBytes
// pub type AddDropContextFlags = bitvec::BitArr!(for 32, in u32);
#[repr(transparent)]
#[derive(Copy, Clone, Immutable, FromBytes, Debug)]
pub struct AddDropContextFlags(u32);

bitstruct! {
    /// Represrentation of the last 32-bits of an InputControlContext.
    ///
    /// See xHCI 1.2 table 6-17
    #[derive(Clone, Copy, Default, Immutable, FromBytes)]
    pub struct InputControlContextLast(pub u32) {
        pub configuration_value: u8 = 0..8;
        pub interface_number: u8 = 8..16;
        pub alternate_setting: u8 = 16..24;
        reserved0: u8 = 24..32;
    }
}

impl core::fmt::Debug for InputControlContextLast {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InputControlContextLast {{ \
            configuration_value: {}, \
            interface_number: {}, \
            alternate_setting: {} }}",
            self.configuration_value(),
            self.interface_number(),
            self.alternate_setting(),
        )
    }
}

impl Deref for InputControlContext {
    type Target = InputControlContextLast;
    fn deref(&self) -> &Self::Target {
        &self.last
    }
}
impl DerefMut for InputControlContext {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.last
    }
}

impl InputControlContext {
    /// xHCI 1.2 table 6-15
    pub fn drop_context_bit(&self, index: u8) -> Option<bool> {
        if index < 2 || index > 31 {
            None
        } else {
            Some(self.drop_context.0 & (1 << index) != 0)
        }
    }
    /// xHCI 1.2 table 6-15
    pub fn set_drop_context_bit(&mut self, index: u8, value: bool) {
        // lower two bits reserved
        if index > 2 && index <= 31 {
            let mask = 1 << index;
            if value {
                self.drop_context.0 |= mask;
            } else {
                self.drop_context.0 &= !mask;
            }
        }
    }
    /// Returns whether the context corresponding to the given index
    /// should be added in an Evaluate Context command.
    /// See xHCI 1.2 table 6-16
    pub fn add_context_bit(&self, index: u8) -> Option<bool> {
        if index > 31 {
            None
        } else {
            Some(self.add_context.0 & (1 << index) != 0)
        }
    }
    /// xHCI 1.2 table 6-16
    pub fn set_add_context_bit(&mut self, index: u8, value: bool) {
        if index <= 31 {
            let mask = 1 << index;
            if value {
                self.add_context.0 |= mask;
            } else {
                self.add_context.0 &= !mask;
            }
        }
    }
}
