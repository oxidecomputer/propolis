//! Helpers for configuring and starting new VMs.

use std::{
    net::{Ipv4Addr, SocketAddrV4},
    ops::Range,
    path::PathBuf,
    str::FromStr,
    sync::atomic::{AtomicU16, Ordering},
};

use anyhow::Result;
use thiserror::Error;
use tracing::info;

use crate::{
    artifacts::ArtifactStore, test_vm::server::ServerProcessParameters,
};

use super::{
    vm_config::{self, VmConfig},
    TestVm,
};

/// Errors that can arise while creating a VM factory.
#[derive(Debug, Error)]
pub enum FactoryConstructionError {
    /// Raised if the default bootrom key in the [`FactoryOptions`] does not
    /// yield a valid bootrom from the artifact store.
    #[error("Default bootrom {0} not in artifact store")]
    DefaultBootromMissing(String),

    /// Raised if the default guest image key in the [`FactoryOptions`] does not
    /// yield a valid image from the artifact store.
    #[error("Default guest image {0} not in artifact store")]
    DefaultGuestImageMissing(String),

    /// Raised on a failure to convert from a named server logging mode to a
    /// [`ServerLogMode`].
    #[error("Invalid server log mode name '{0}'")]
    InvalidServerLogModeName(String),
}

/// Specifies where propolis-server's log output should be written.
#[derive(Debug, Clone, Copy)]
pub enum ServerLogMode {
    /// Write to files in the server's factory's temporary directory.
    TmpFile,

    /// Write stdout/stderr to the console.
    Stdio,

    /// Redirect stdout/stderr to /dev/null.
    Null,
}

impl FromStr for ServerLogMode {
    type Err = FactoryConstructionError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "file" | "tmpfile" => Ok(ServerLogMode::TmpFile),
            "stdio" => Ok(ServerLogMode::Stdio),
            "null" => Ok(ServerLogMode::Null),
            _ => Err(FactoryConstructionError::InvalidServerLogModeName(
                s.to_string(),
            )),
        }
    }
}

/// Parameters used to construct a new VM factory.
#[derive(Debug)]
pub struct FactoryOptions {
    /// The path to the Propolis server binary to use for VMs created by this
    /// factory.
    pub propolis_server_path: String,

    /// The directory to use as a temporary directory for config TOML files,
    /// server logs, and the like.
    pub tmp_directory: PathBuf,

    /// The logging discipline to use for this factory's Propolis servers.
    pub server_log_mode: ServerLogMode,

    /// An artifact store key specifying the default bootrom artifact to use for
    /// this factory's VMs.
    pub default_bootrom_artifact: String,

    /// The default number of CPUs to set in [`vm_config::VmConfig`] structs
    /// generated by this factory.
    pub default_guest_cpus: u8,

    /// The default amount of memory to set in [`vm_config::VmConfig`] structs
    /// generated by this factory.
    pub default_guest_memory_mib: u64,

    /// The range of ports to assign to servers created by this factory.
    pub server_port_range: Range<u16>,
}

/// A VM factory that provides routines to generate new test VMs.
pub struct VmFactory {
    opts: FactoryOptions,
    default_bootrom_path: String,

    // Mutable state in the VM factory must be unwind-safe because the runner
    // passes the factory to test cases (via their test contexts), and test
    // cases run in a `catch_unwind` block to enable the use of `assert!` and
    // `panic!`. For assigning sequential port numbers, `AtomicU16` fits the
    // bill without requiring the extra interlocked operations needed to acquire
    // and release an entire `Mutex`.
    next_port: AtomicU16,
}

impl VmFactory {
    /// Creates a new VM factory with default bootrom/guest image artifacts
    /// drawn from the supplied artifact store.
    pub fn new(opts: FactoryOptions, store: &ArtifactStore) -> Result<Self> {
        info!(?opts, "Building VM factory");
        let bootrom_path = store
            .get_bootrom_by_name(&opts.default_bootrom_artifact)
            .ok_or_else(|| {
                FactoryConstructionError::DefaultBootromMissing(
                    opts.default_bootrom_artifact.clone(),
                )
            })?;

        let first_port = opts.server_port_range.start;
        Ok(Self {
            opts,
            default_bootrom_path: bootrom_path.to_string_lossy().to_string(),
            next_port: AtomicU16::new(first_port),
        })
    }

    /// Resets this factory to the state it had when it was created, preparing
    /// it for use in a new test case.
    pub fn reset(&self) {
        self.next_port
            .store(self.opts.server_port_range.start, Ordering::Relaxed);
    }

    /// Creates a VM configuration that specifies this factory's defaults for
    /// CPUs, memory, and bootrom.
    pub fn deviceless_vm_config(&self) -> vm_config::ConfigRequest {
        let bootrom_path =
            PathBuf::try_from(&self.default_bootrom_path).unwrap();
        vm_config::ConfigRequest::new()
            .set_bootrom_path(bootrom_path)
            .set_cpus(self.opts.default_guest_cpus)
            .set_memory_mib(self.opts.default_guest_memory_mib)
    }

    /// Launches a new Propolis server process with a VM configuration created
    /// by the supplied configuration builder. Returns the [`TestVm`] associated
    /// with this server.
    pub fn new_vm(
        &self,
        vm_name: &str,
        config: vm_config::ConfigRequest,
    ) -> Result<TestVm> {
        info!(?vm_name, ?config, "Configuring VM from request");
        let realized = config.finish(
            &self.opts.tmp_directory,
            &format!("{}.config.toml", vm_name),
        )?;

        self.create_vm_from_config(vm_name, realized)
    }

    /// Launches a new Propolis server process with a VM configuration cloned
    /// from an existing VM. Returns the [`TestVm`] associated with this server.
    ///
    /// This is useful for live migration tests where the source and target are
    /// expected to have identical configuration data.
    pub fn new_vm_from_cloned_config(
        &self,
        vm_name: &str,
        vm_to_clone: &TestVm,
    ) -> Result<TestVm> {
        let config = vm_to_clone.clone_config();
        let server_toml_path = config.server_toml_path();
        let mut new_toml_path =
            server_toml_path.parent().unwrap().to_path_buf();
        new_toml_path.push(format!("{}.config.toml", vm_name));
        info!(
            ?server_toml_path,
            ?new_toml_path,
            "Copying existing server config TOML"
        );
        std::fs::copy(server_toml_path, &new_toml_path)?;

        self.create_vm_from_config(vm_name, config)
    }

    fn create_vm_from_config(
        &self,
        vm_name: &str,
        vm_config: VmConfig,
    ) -> Result<TestVm> {
        let (server_stdout, server_stderr) = match &self.opts.server_log_mode {
            ServerLogMode::TmpFile => {
                let mut stdout_path = self.opts.tmp_directory.clone();
                stdout_path.push(format!("{}.stdout.log", vm_name));
                let mut stderr_path = self.opts.tmp_directory.clone();
                stderr_path.push(format!("{}.stderr.log", vm_name));
                info!(?stdout_path, ?stderr_path, "Opening server log files");
                (
                    std::fs::File::create(stdout_path)?.into(),
                    std::fs::File::create(stderr_path)?.into(),
                )
            }
            ServerLogMode::Stdio => {
                (std::process::Stdio::inherit(), std::process::Stdio::inherit())
            }
            ServerLogMode::Null => {
                (std::process::Stdio::null(), std::process::Stdio::null())
            }
        };

        let server_port = self.next_port.fetch_add(1, Ordering::Relaxed);
        let vnc_port = self.next_port.fetch_add(1, Ordering::Relaxed);
        let server_params = ServerProcessParameters {
            server_path: &self.opts.propolis_server_path,
            config_toml_path: vm_config.server_toml_path().clone(),
            server_addr: SocketAddrV4::new(
                Ipv4Addr::new(127, 0, 0, 1),
                server_port,
            ),
            vnc_addr: SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), vnc_port),
            server_stdout,
            server_stderr,
        };

        TestVm::new(vm_name, server_params, vm_config)
    }
}
