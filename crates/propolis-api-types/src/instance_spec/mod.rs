// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! Instance specifications: abstract descriptions of a VM's devices and config.
//!
//! An instance spec describes a VM's virtual devices, backends, and other
//! guest environment configuration supplied by the Propolis VMM. RFD 283
//! contains more details about how specs are used throughout the Oxide stack
//! and about the versioning considerations described below.
//!
//! # Module layout
//!
//! The data types in this module are taxonomized into "components" and
//! versioned "spec structures." Components are the "leaves" of a spec; each
//! component specifies an individual component or piece of functionality that
//! can be added to a VM. The strongly versioned structure types arrange these
//! components in a specific way; each organization is a version of the overall
//! instance spec structure.
//!
//! # Versioning & compatibility
//!
//! Instance specs may be sent between Propolises, sled agents, and Nexus
//! processes that use different versions of this library, so the library needs
//! to provide a versioning scheme that allows specs to be extended over time.
//! Such scheme must balance safety against developer toil. Strongly versioning
//! data types--requiring a new API endpoint or type definition every time
//! something changes--minimizes the risk that a data structure will be
//! misinterpreted, but is very toilsome to maintain, since changing one
//! structure may require many other structures to be revised and
//! `From`/`TryFrom` impls to be added for all the new version combinations.
//! Weaker versioning schemes require less toil to maintain but run the risk
//! that a spec user will be too permissive and will misconfigure a VM because
//! it missed some important context in a
//! spec that it was passed.
//!
//! This module balances these concerns as follows:
//!
//! - **Components** are versionless but are allowed to be extended in backward-
//!   compatible ways (i.e., such that a spec produced by an old library can be
//!   interpreted correctly by a newer library). Breaking changes to components
//!   are not allowed and require a new component to be defined.
//! - **Spec structures** are strongly versioned. Backward-compatible changes to
//!   an existing version are technically allowed, but completely restructuring
//!   a spec requires a new spec version and a corresponding variant in the
//!   `VersionedInstanceSpec` structure.
//!
//! This scheme assumes that (a) components are likely to be added or changed
//! much more frequently than the spec structure itself will be revised, and (b)
//! most changes to existing components can easily be made backward-compatible
//! (e.g. by wrapping new functionality in an `Option` and taking a `None` value
//! to mean "do what all previous versions did").
//!
//! ## Compatibility rules & breaking changes
//!
//! Changes to existing data types must be backward compatible with older spec
//! versions: a spec produced by an old version of the library must always be
//! deserializable by a new version of the library.
//!
//! The following component changes are not backward compatible:
//!
//! - Adding a new required field to a struct or enum variant
//! - Removing a field from a struct or enum variant
//! - Renaming structs, enums, or their fields or variants
//!
//! Adding new *optional* fields to a struct or enum variant is OK provided that
//! the default value's semantics match the semantics expected by users of older
//! specs that don't provide the optional data.
//!
//! Forward compatibility--writing the library so that old versions can
//! interpret specs generated by new versions--is not generally guaranteed.
//! Where possible, however, spec components should be written so that it is
//! possible to downgrade from a newer spec version to an older one if a
//! component's configuration can be represented in both versions.
//!
//! ## Serde attributes
//!
//! This module doesn't directly verify that a specific Propolis version can
//! support all of the features in any particular specification. However, users
//! can generally expect that if Propolis is willing to deserialize a spec, then
//! it should be able (in at least some circumstances) to support all of the
//! features that can be expressed in that spec. To help guarantee this property
//! (i.e., if Propolis can deserialize it, then it's at least well-formed), this
//! module uses a few common `serde` attributes.
//!
//! Structs and enums in this module should be tagged with the
//! `#[serde(deny_unknown_fields)]` attribute to reduce the risk that old code
//! will silently drop information from a spec produced by newer code with more
//! available fields.
//!
//! New optional fields should use the `#[serde(default)]` field attribute to
//! provide backward compatibility to old specs. They can also use the
//! `#[serde(skip_serializing_if)]` attribute to avoid serializing new fields
//! that have their default values.
//!
//! ### Example
//!
//! As an example, consider a (hypothetical) virtio device that has backend name
//! and PCI path fields:
//!
//! ```
//! # use serde::{Serialize, Deserialize};
//! # use schemars::JsonSchema;
//! # use propolis_types::PciPath;
//!
//! #[derive(Clone, Debug, Serialize, Deserialize, JsonSchema)]
//! #[serde(deny_unknown_fields)]
//! struct VirtioComponent {
//!     backend_name: String,
//!     pci_path: PciPath
//! }
//! ```
//!
//! Suppose Propolis then adds support for configuring the number of virtqueues
//! this device exposes to the guest. This can be expressed compatibly as
//! follows:
//!
//! ```
//! # use serde::{Serialize, Deserialize};
//! # use schemars::JsonSchema;
//! # use propolis_types::PciPath;
//!
//! #[derive(Clone, Debug, Serialize, Deserialize, JsonSchema)]
//! #[serde(deny_unknown_fields)]
//! struct VirtioComponent {
//!     backend_name: String,
//!     pci_path: PciPath,
//!
//!     #[serde(default, skip_serializing_if = "Option::is_none")]
//!     num_virtqueues: Option<usize>
//! }
//! ```
//!
//! Old component specs will continue to deserialize with `num_virtqueues` set
//! to `None`. In this case Propolis ensures that the device gets the default
//! number of virtqueues it had before this configuration option was added. If
//! this spec is serialized again, the `num_virtqueues` option is omitted, so
//! the spec can be deserialized by downlevel versions of the library. Note
//! again that the former behavior (new library accepts old spec) is required,
//! while the latter behavior (old library accepts new spec) is nice to have and
//! may not always be possible to provide (e.g. if the value is `Some`).
//!
//! ## Naming of versioned structures
//!
//! Dropshot's OpenAPI schema generator has a known limitation. If a type or one
//! of its dependent types appears in an API, Dropshot adds to the API's schema
//! an object type with the type's name. If two separate types with the same
//! name but *different module paths* appear in the API, Dropshot chooses one
//! to include and silently ignores the rest. This issue is
//! [dropshot#383](https://github.com/oxidecomputer/dropshot/issues/383). To
//! avoid it, strongly versioned types in this module use a "V#" suffix in their
//! names, even though they may reside in separate versioned modules.

#![allow(rustdoc::private_intra_doc_links)]

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

pub use propolis_types::{CpuidIdent, CpuidValues, CpuidVendor, PciPath};
use uuid::Uuid;

pub mod components;
pub mod v0;

/// A key identifying a component in an instance spec.
//
// Some of the components Omicron attaches to Propolis VMs, like network
// interfaces and Crucible disks, are described by database records with UUID
// primary keys. It's natural to reuse these UUIDs as component identifiers in
// Propolis, especially because it lets Omicron functions that need to identify
// a specific component (e.g. a specific Crucible backend that should handle a
// disk snapshot request) pass that component's ID directly to Propolis.
//
// In some cases it's not desirable or possible to use UUIDs this way:
//
// - Some components (like the cloud-init disk) don't have their own rows in the
//   database and so don't have obvious UUIDs to use.
// - Some objects (like Crucible disks) require both a device and a backend
//   component in the spec, and these can't share the same key.
// - Propolis users outside the control plane may not have any component UUIDs
//   at all and may just want to use strings to identify all their components.
//
// For these reasons, the key type may be represented as either a UUID or a
// String. This allows the more compact, more-easily-compared UUID format to be
// used wherever it is practical while still allowing callers to use strings as
// names if they have no UUIDs available or the most obvious UUID is in use
// elsewhere. The key type's From impls will try to parse strings into UUIDs
// before storing keys as strings.
#[derive(
    Clone, Debug, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd,
)]
// Direct serde to use an untagged enum representation for this type. Since both
// Uuid and String serialize to strings, this allows other types that contain a
// Map<K = SpecKey> to derive Serialize and successfully serialize to JSON.
// (This doesn't work with a tagged representation because JSON doesn't allow
// maps to be used as map keys.)
//
// Note that this makes the order of variants matter: serde will pick the first
// variant into which it can successfully deserialize an untagged enum value,
// and the point is to use the UUID representation for any value that can be
// interpreted as a UUID.
#[serde(untagged)]
pub enum SpecKey {
    Uuid(Uuid),
    Name(String),
}

impl std::fmt::Display for SpecKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Uuid(uuid) => write!(f, "{uuid}"),
            Self::Name(name) => write!(f, "{name}"),
        }
    }
}

impl std::str::FromStr for SpecKey {
    type Err = core::convert::Infallible;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(s.into())
    }
}

impl From<&str> for SpecKey {
    fn from(s: &str) -> Self {
        match Uuid::parse_str(s) {
            Ok(uuid) => Self::Uuid(uuid),
            Err(_) => Self::Name(s.to_owned()),
        }
    }
}

impl From<String> for SpecKey {
    fn from(value: String) -> Self {
        match Uuid::parse_str(value.as_str()) {
            Ok(uuid) => Self::Uuid(uuid),
            Err(_) => Self::Name(value),
        }
    }
}

impl From<Uuid> for SpecKey {
    fn from(value: Uuid) -> Self {
        Self::Uuid(value)
    }
}

// Manually implement JsonSchema to help Progenitor generate the expected enum
// type for spec keys.
impl JsonSchema for SpecKey {
    fn schema_name() -> String {
        "SpecKey".to_owned()
    }

    fn json_schema(
        generator: &mut schemars::gen::SchemaGenerator,
    ) -> schemars::schema::Schema {
        use schemars::schema::*;
        fn label_schema(label: &str, schema: Schema) -> Schema {
            SchemaObject {
                metadata: Some(
                    Metadata {
                        title: Some(label.to_string()),
                        ..Default::default()
                    }
                    .into(),
                ),
                subschemas: Some(
                    SubschemaValidation {
                        all_of: Some(vec![schema]),
                        ..Default::default()
                    }
                    .into(),
                ),
                ..Default::default()
            }
            .into()
        }

        SchemaObject {
            metadata: Some(
                Metadata {
                    description: Some(
                        "A key identifying a component in an instance spec."
                            .to_string(),
                    ),
                    ..Default::default()
                }
                .into(),
            ),
            subschemas: Some(Box::new(SubschemaValidation {
                one_of: Some(vec![
                    label_schema("uuid", generator.subschema_for::<Uuid>()),
                    label_schema("name", generator.subschema_for::<String>()),
                ]),
                ..Default::default()
            })),
            ..Default::default()
        }
        .into()
    }
}

/// A versioned instance spec.
#[derive(Clone, Debug, Deserialize, Serialize, JsonSchema)]
#[serde(deny_unknown_fields, tag = "version", content = "spec")]
pub enum VersionedInstanceSpec {
    V0(v0::InstanceSpecV0),
}

#[cfg(test)]
mod test {
    use std::collections::BTreeMap;

    use uuid::Uuid;

    use super::{components::devices::QemuPvpanic, v0::ComponentV0, SpecKey};

    type TestMap = BTreeMap<SpecKey, ComponentV0>;

    // Verifies that UUID-type spec keys that are serialized and deserialized
    // continue to be interpreted as UUID-type spec keys.
    #[test]
    fn spec_key_uuid_roundtrip() {
        let id = Uuid::new_v4();
        let mut map = TestMap::new();
        map.insert(
            SpecKey::Uuid(id),
            ComponentV0::QemuPvpanic(QemuPvpanic { enable_isa: true }),
        );

        let ser = serde_json::to_string(&map).unwrap();
        let unser: TestMap = serde_json::from_str(&ser).unwrap();
        let key = unser.keys().next().expect("one key in the map");
        let SpecKey::Uuid(got_id) = key else {
            panic!("expected SpecKey::Uuid, got {key}");
        };

        assert_eq!(*got_id, id);
    }

    // Verifies that serializing a name-type spec key that happens to be the
    // string representation of a UUID causes the key to deserialize as a
    // UUID-type key.
    #[test]
    fn spec_key_uuid_string_deserializes_as_uuid_variant() {
        let id = Uuid::new_v4();
        let mut map = TestMap::new();
        map.insert(
            SpecKey::Name(id.to_string()),
            ComponentV0::QemuPvpanic(QemuPvpanic { enable_isa: true }),
        );

        let ser = serde_json::to_string(&map).unwrap();
        let unser: TestMap = serde_json::from_str(&ser).unwrap();
        let key = unser.keys().next().expect("one key in the map");
        let SpecKey::Uuid(got_id) = key else {
            panic!("expected SpecKey::Uuid, got {key}");
        };

        assert_eq!(*got_id, id);
    }
}
